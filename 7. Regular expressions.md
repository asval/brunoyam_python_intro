# Регулярные выражения

## 1. Понятие регулярного выражения

Говоря простым языком, регулярное выражение — это последовательность символов, используемая для
поиска и замены текста в строке или файле. Как уже было упомянуто, их поддерживает множество языков
общего назначения: Python, Perl, R. Так что изучение регулярных выражений рано или поздно
пригодится.

## 2. Синтаксис регулярных выражений в Python

Регулярные выражения используют два типа символов:

* Специальные символы: как следует из названия, у этих символов есть специальные значения.
Аналогично символу *, который как правило означает «любой символ» (но в регулярных выражениях
работает немного иначе, о чем поговорим ниже);
* Литералы (например: a, b, 1, 2 и т. д.).
Чаще всего регулярные выражения используются для:
* поиска в строке;
* разбиения строки на подстроки;
* замены части строки.

### Набор символов

Предположим, мы хотим найти в тексте все междометия, обозначающие смех. Просто "**Хаха**" нам не
подойдёт — ведь под него не попадут "**Хехе**", «**Хохо**» и «**Хихи**». Да и проблему с регистром
первой буквы нужно как-то решить.

Здесь нам на помощь придут наборы — вместо указания конкретного символа, мы можем записать целый
список, и если в исследуемой строке на указанном месте будет стоять любой из перечисленных символов,
строка будет считаться подходящей. Наборы записываются в квадратных скобках — паттерну [abcd] будет
соответствовать любой из символов «**a**», «**b**», «**c**» или «**d**».

Внутри набора большая часть спецсимволов не нуждается в экранировании, однако использование \ перед
ними не будет считаться ошибкой. По прежнему необходимо экранировать символы «\» и «^», и,
желательно, «]» (так, [][] обозначает любой из символов «]» или «[», тогда как [[]х] – исключительно
последовательность «[х]»). Необычное на первый взгляд поведение регулярок с символом «]» на самом
деле определяется известными правилами, но гораздо легче просто экранировать этот символ, чем их
запоминать. Кроме этого, экранировать нужно символ «-», он используется для задания диапазонов (см.
ниже).

Если сразу после [ записать символ ^, то набор приобретёт обратный смысл — подходящим будет
считаться любой символ кроме указанных. Так, паттерну [^xyz] соответствует любой символ, кроме,
собственно, «x», «y» или «z».
Итак, применяя данный инструмент к нашему случаю, если мы напишем [Хх][аоие]х[аоие], то каждая из
строк «Хаха», «хехе», «хихи» и даже «Хохо» будут соответствовать шаблону.

### Предопределённые классы символов

Для некоторых наборов, которые используются достаточно часто, существуют специальные шаблоны. Так,
для описания любого пробельного символа (пробел, табуляция, перенос строки) используется \s, для
цифр — \d, для символов латиницы, цифр и подчёркивания «_» — \w.

Если необходимо описать вообще любой символ, для этого используется точка — .. Если указанные классы
написать с заглавной буквы (\S, \D, \W) то они поменяют свой смысл на противоположный — любой
непробельный символ, любой символ, который не является цифрой, и любой символ кроме латиницы, цифр
или подчёркивания соответственно.

Также с помощью регулярных выражений есть возможность проверить положение строки относительно
остального текста. Выражение \b обозначает границу слова, \B — не границу слова, ^ — начало текста,
а $ — конец. Так, по паттерну \bJava\b в строке «Java and JavaScript» найдутся первые 4 символа, а
по паттерну \bJava\B — символы c 10-го по 13-й (в составе слова «JavaScript»).

### Диапазоны

У вас может возникнуть необходимость обозначить набор, в который входят буквы, например, от «б» до
«ф». Вместо того, чтобы писать [бвгдежзиклмнопрстуф] можно воспользоваться механизмом диапазонов и
написать [б-ф]. Так, паттерну x[0-8A-F][0-8A-F] соответствует строка «xA6», но не соответствует
«xb9» (во-первых, из-за того, что в диапазоне указаны только заглавные буквы, во-вторых, из-за того,
что 9 не входит в промежуток 0-8).

Механизм диапазонов особенно актуален для русского языка, ведь для него нет конструкции, аналогичной
\w. Чтобы обозначить все буквы русского алфавита, можно использовать паттерн [а-яА-ЯёЁ]. Обратите
внимание, что буква «ё» не включается в общий диапазон букв, и её нужно указывать отдельно.

### Квантификаторы (указание количества повторений)

Вернёмся к нашему примеру. Что, если в «смеющемся» междометии будет больше одной гласной между
буквами «х», например «Хаахаааа»? Наша старая регулярка уже не сможет нам помочь. Здесь нам придётся
воспользоваться квантификаторами.
|Квантификатор|Число повторений      |Пример   |Подходящие строки             |
|-------------|----------------------|---------|------------------------------|
|{n}          |Ровно n раз           |Ха{3}ха  |Хаааха                        |
|{m,n}        |От m до n включительно|Ха{2,4}ха|Хаа, Хааа, Хааааха            |
|{m,}         |Не менее m            |Ха{2,}ха |Хааха, Хаааха, Хааааха и т. д.|
|{,n}         |Не более n            |Ха{,3}ха |Хха, Хаха, Хааха, Хаааха      |

Обратите внимание, что квантификатор применяется только к символу, который стоит перед ним.

Некоторые часто используемые конструкции получили в языке регулярных выражений специальные
обозначения:

* ? - {0,1} - Ноль или одно вхождение
* \* - {0,} - Ноль или более
* \+ - {1,} - Одно или более

Таким образом, с помощью квантификаторов мы можем улучшить наш шаблон для междометий до
[Хх][аоеи]+х[аоеи]*, и он сможет распознавать строки «Хааха», «хееееех» и «Хихии».

### Ленивая квантификация

Предположим, перед нами стоит задача — найти все HTML-теги в строке
`<p><b>Tproger</b> — мой <i>любимый</i> сайт о программировании!</p>`
Очевидное решение <.*> здесь не сработает — оно найдёт всю строку целиком, т.к. она начинается с
тега абзаца и им же заканчивается. То есть содержимым тега будет считаться строка
`p><b>Tproger</b> — мой <i>любимый</i> сайт о программировании!</p`
Это происходит из-за того, что по умолчанию квантификатор работают по т.н. жадному алгоритму —
старается вернуть как можно более длинную строку, соответствующую условию. Решить проблему можно
двумя способами. Первый — использовать выражение <[^>]*>, которое запретит считать содержимым тега
правую угловую скобку. Второй — объявить квантификатор не жадным, а ленивым. Делается это с помощью
добавления справа к квантификатору символа ?. Т.е. для поиска всех тегов выражение обратится в
<.*?>.

### Ревнивая квантификация

Иногда для увеличения скорости поиска (особенно в тех случаях, когда строка не соответствует
регулярному выражению) можно использовать запрет алгоритму возвращаться к предыдущим шагам поиска
для того, чтобы найти возможные соответствия для оставшейся части регулярного выражения. Это
называется ревнивой квантификацией. Квантификатор делается ревнивым с помощью добавления к нему
справа символа +. Ещё одно применение ревнивой квантификации — исключение нежелательных совпадений.
Так, паттерну ab*+a в строке «ababa» будут соответствовать только первые три символа, но не символы
с третьего по пятый, т.к. символ «a», который стоит на третьей позиции, уже был использован для
первого результата.

### Скобочные группы

Для нашего шаблона «смеющегося» междометия осталась самая малость — учесть, что буква «х» может
встречаться более одного раза, например, «Хахахахааахахооо», а может и вовсе заканчиваться на букве
«х». Вероятно, здесь нужно применить квантификатор для группы [аиое]+х, но если мы просто напишем
[аиое]х+, то квантификатор + будет относиться только к символу «х», а не ко всему выражению. Чтобы
это исправить, выражение нужно взять в круглые скобки: ([аиое]х)+.

Таким образом, наше выражение превращается в [Хх]([аиое]х?)+ — сначала идёт заглавная или строчная
«х», а потом произвольное ненулевое количество гласных, которые (возможно, но не обязательно)
перемежаются одиночными строчными «х». Однако это выражение решает проблему лишь частично — под это
выражение попадут и такие строки, как, например, «хихахех» — кто-то может быть так и смеётся, но
допущение весьма сомнительное. Очевидно, мы можем использовать набор из всех гласных лишь единожды,
а потом должны как-то опираться на результат первого поиска. Но как?…

### Запоминание результата поиска по группе (обратная связь)

Оказывается, результат поиска по скобочной группе записывается в отдельную ячейку памяти, доступ к
которой доступен для использования в последующих частях регулярного выражения. Возвращаясь к задаче
с поиском HTML-тегов на странице, нам может понадобиться не только найти теги, но и узнать их
название. В этом нам может помочь регулярное выражение <(.*?)>.
`<p><b>Tproger</b> — мой <i>любимый</i> сайт о программировании!</p>`
Результат поиска по всем регулярному выражению: `<p>`, `<b>`, `</b>`, `<i>`, `</i>`, `</p>`.
Результат поиска по первой группе: `p`, `b`, `/b`, `i`, `/i`, `/i`, `/p`.

На результат поиска по группе можно ссылаться с помощью выражения \n, где n — цифра от 1 до 9.
Например выражению (\w)(\w)\1\2 соответствуют строки «aaaa», «abab», но не соответствует «aabb».

Если выражение берётся в скобки только для применения к ней квантификатора (не планируется
запоминать результат поиска по этой группе), то сразу первой скобки стоит добавить ?:, например
(?:[abcd]+\w).

С использованием этого механизма мы можем переписать наше выражение к виду [Хх]([аоие])х?(?:\1х?)*.

I love or hate regex

### Перечисление

Чтобы проверить, удовлетворяет ли строка хотя бы одному из шаблонов, можно воспользоваться аналогом
булевого оператора OR, который записывается с помощью символа |. Так, под шаблон Анна|Одиночество
попадают строки «Анна» и «Одиночество» соответственно. Особенно удобно использовать перечисления
внутри скобочных групп. Так, например (?:a|b|c|d) полностью эквивалентно [abcd] (в данном случае
второй вариант предпочтительнее в силу производительности и читаемости).

С помощью этого оператора мы сможем добавить к нашему регулярному выражению для поиска междометий
возможность распознавать смех вида «Ахахаах» — единственной усмешке, которая начинается с гласной:
[Хх]([аоие])х?(?:\1х?)*|[Аа]х?(?:ах?)+

## 3. Использование регулярных выражений в Python

В Python для работы с регулярными выражениями есть модуль re. Для использования его нужно
импортировать:

```python
import re
```

Давайте посмотрим на методы, которые предоставляет библиотека re для этих задач. Вот наиболее часто
используемые из них:

* re.match()
* re.search()
* re.findall()
* re.split()
* re.sub()
* re.compile()

Рассмотрим их подробнее.

### re.match(pattern, string)

Этот метод ищет по заданному шаблону в начале строки. Например, если мы вызовем метод match() на
строке «AV Analytics AV» с шаблоном «AV», то он завершится успешно. Однако если мы будем искать
«Analytics», то результат будет отрицательный. Давайте посмотрим на его работу:

```python
import re
result = re.match(r"AV", "AV Analytics Vidhya AV")
print(result)
```

Искомая подстрока найдена. Чтобы вывести ее содержимое, используем метод group(). (Мы используем «r»
перед строкой шаблона, чтобы показать, что это «сырая» строка в Python).

```python
result = re.match(r"AV", "AV Analytics Vidhya AV")
print(result.group(0))
```

Теперь попробуем найти «Analytics» в данной строке. Поскольку строка начинается на «AV», метод
вернет None:

```python
result = re.match(r"Analytics", "AV Analytics Vidhya AV")
print(result)
```

Также есть методы start() и end() для того, чтобы узнать начальную и конечную позицию найденной
строки.

```python
result = re.match(r"AV", "AV Analytics Vidhya AV")
print(result.start())
print(result.end())
```

Эти методы иногда очень полезны для работы со строками.

### re.search(pattern, string)

Этот метод похож на match(), но он ищет не только в начале строки. В отличие от предыдущего,
search() вернет объект, если мы попытаемся найти «Analytics».

```python
result = re.search(r'Analytics', 'AV Analytics Vidhya AV')
print result.group(0)
```

Метод search() ищет по всей строке, но возвращает только первое найденное совпадение.

### re.findall(pattern, string)

Этот метод возвращает список всех найденных совпадений. У метода findall() нет ограничений на поиск
в начале или конце строки. Если мы будем искать «AV» в нашей строке, он вернет все вхождения «AV».
Для поиска рекомендуется использовать именно findall(), так как он может работать и как re.search(),
и как re.match().

```python
result = re.findall(r'AV', 'AV Analytics Vidhya AV')
print(result)
```

### re.split(pattern, string, [maxsplit=0])

Этот метод разделяет строку по заданному шаблону.

```python
result = re.split(r"y", "Analytics")
print(result)
```

В примере мы разделили слово «Analytics» по букве «y». Метод split() принимает также аргумент
maxsplit со значением по умолчанию, равным 0. В данном случае он разделит строку столько раз,
сколько возможно, но если указать этот аргумент, то разделение будет произведено не более указанного
количества раз. Давайте посмотрим на примеры:

```python
result = re.split(r"i", "Analytics Vidhya")
print(result)
result = re.split(r"i", "Analytics Vidhya", maxsplit=1)
print(result)
```

Мы установили параметр maxsplit равным 1, и в результате строка была разделена на две части вместо
трех.

### re.sub(pattern, repl, string)

Этот метод ищет шаблон в строке и заменяет его на указанную подстроку. Если шаблон не найден, строка
остается неизменной.

```python
result = re.sub(r"India", "the World", "AV is largest Analytics community of India")
print(result)
```

### re.compile(pattern, repl, string)

Мы можем собрать регулярное выражение в отдельный объект, который может быть использован для поиска.
Это также избавляет от переписывания одного и того же выражения.

```python
pattern = re.compile("AV")
result = pattern.findall("AV Analytics Vidhya AV")
print(result)
result2 = pattern.findall("AV is largest analytics community of India")
print(result2)
```

До сих пор мы рассматривали поиск определенной последовательности символов. Но что, если у нас нет
определенного шаблона, и нам надо вернуть набор символов из строки, отвечающий определенным
правилам? Такая задача часто стоит при извлечении информации из строк. Это можно сделать, написав
выражение с использованием специальных символов. Вот наиболее часто используемые из них:

* . - Один любой символ, кроме новой строки \n.
* ? - 0 или 1 вхождение шаблона слева
* \+ - 1 и более вхождений шаблона слева
* \* - 0 и более вхождений шаблона слева
* \w - Любая цифра или буква (\W — все, кроме буквы или цифры)
* \d - Любая цифра [0-9] (\D — все, кроме цифры)
* \s - Любой пробельный символ (\S — любой непробельный символ)
* \b - Граница слова
* [..] - Один из символов в скобках ([^..] — любой символ, кроме тех, что в скобках)
* \ - Экранирование специальных символов (\. означает точку или \+ — знак «плюс»)
* ^ и $ - Начало и конец строки соответственно
* {n,m} - От n до m вхождений ({,m} — от 0 до m)
* a|b - Соответствует a или b
* () - Группирует выражение и возвращает найденный текст
* \t, \n, \r - Символ табуляции, новой строки и возврата каретки соответственно
Больше информации по специальным символам, таким как (), | и др., можно найти на странице
документации: <https://docs.python.org/3/library/re.html>).

## 4. Самостоятельная работа

На <http://informatics.msk.ru> решить задачи:

* №1619 (<https://informatics.msk.ru/mod/statements/view.php?id=3163>)

## 5. Домашняя работа

Обязательно:

* №3450 (<https://informatics.msk.ru/mod/statements/view3.php?id=3290&chapterid=3450>)
* №3458 (<https://informatics.msk.ru/mod/statements/view3.php?id=3309&chapterid=3458>)
* №3507 (<https://informatics.msk.ru/mod/statements/view3.php?id=3380&chapterid=3507>)
* №3508 (<https://informatics.msk.ru/mod/statements/view3.php?id=3380&chapterid=3508>)
* №3739 (<https://informatics.msk.ru/mod/statements/view3.php?id=3863&chapterid=3739>)
* №3741 (<https://informatics.msk.ru/mod/statements/view3.php?id=3863&chapterid=3741>)

По желанию:

* Весь раздел "Регулярные выражение" (<https://informatics.msk.ru/mod/statements/view.php?id=3163>)
