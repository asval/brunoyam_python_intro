# Файловый ввод/вывод, сериализация/десериализация

## 1. Символы перевода строки

Перевод строки, или разрыв строки, — продолжение печати текста с новой строки, то есть с левого края
на строку ниже, или уже на следующей странице. На компьютерах это осуществляется клавишей ввода
Enter.

Но с символом перевода строки есть некоторые трудности. В разных операционных системах перевод
строки кодируется разной последовательностью символов.

В Unix системах перевод строки состоит из одного символа в шестнадцетиричном представлении `0x0A`
или `10` в десятеричном. Этот символ является управляющим и часто обозначается как `LF` - от line
feed, подача (бумаги) на строку. Этот символ является непечатным, поэтому в языках программирования
он указывается в строках как `\n`. Такую интерпретацию перевода строки так и называют - `LF`.

В Windows системах перевод строки состоит из двух последовательно идущих символов: в
шестандцетиричом представлении из `0x0D` и `0x0A` и в десятеричном из `13` и `10`. С символом `LF`
мы только что познакомились, а символ с кодом `13` для нас в новинку. Его обозначают как `CR` - от
carriage return, возврат каретки. Этот символ также является непечатным и его обозначают с помощью
`\r`. Такую интепретацию перевода строки называют `CRLF`.

Если вы хотите указать перевод строки в переменной типа `str`, то можете просто указать в ней
символ `\n`. В зависимости от системы Python самостоятельно выберет нужный стиль перевода строки.

## 2. Работа с файлами

### Файлы

Файлы - это просто массив байт на жёстком диске. В файлах мы можем хранить абсолютно любую
информацию: текст, аудио, видео, изображения, исполняемый код и т.д. Логически принято делить файлы
на:

1. Текстовые
2. Бинарные (двоичные)

### Открытие файла

Работать с файлами можно тремя способами:

1. Читать из файла
2. Записывать в файл
3. Дозаписывать в файл

Прежде, чем работать с файлом, его надо открыть. Для этой задачи есть встроенная функция __open__:

```python
f = open("text.txt")
```

Результатом работы функция __open__ возвращает специальный объект, который позволяет работать с
файлом. После того как вы сделали всю необходимую работу с файлом - его следутет закрыть.

```python
f.close()
```

У функции __open__ много параметров, нам пока важны 3 аргумента: первый, это имя файла. Путь к файлу
может быть относительным или абсолютным. Второй аргумент - это режим, __mode__, в котором мы будем
открывать файл. Режим обычно состоит из двух букв, первой является тип файла - текстовый или
бинарный, в котором мы хотим открыть файл, а второй указывает, что именно мы хотим сделать с файлом.

Первый аргумент:

* "b" - открытие в двоичном режиме.
* "t" - открытие в текстовом режиме (является значением по умолчанию).

Второй аргумент:

* "r" - открытие на чтение (является значением по умолчанию).
* "w" - открытие на запись, содержимое файла удаляется, если файла не существует, создается новый.
* "x" - открытие на запись, если файла не существует, иначе исключение.
* "a" - открытие на дозапись, информация добавляется в конец файла.
* "+" - открытие на чтение и запись

Режимы могут быть объединены, то есть, к примеру, "rb" - чтение в двоичном режиме. По умолчанию
режим равен "rt". И последний аргумент, __encoding__, нужен только в текстовом режиме чтения файла.
Этот аргумент задает кодировку.

## 3. Режимы работы с файлами

### Чтение

Для того чтобы прочитать данные из текстового файла нужно сначала создать его. Создадим файл
__text.txt__ в папке с проектом.

```text
Hello, world!
Привет, мир!
```

Теперь мы хотим прочитать из него информацию. Для этого есть несколько способов, но большого
интереса заслуживают лишь два из них. Первый - метод __read__, читающий весь файл целиком, если был
вызван без аргументов, и __n__ символов, если был вызван с аргументом (целым числом __n__).

```python
f = open("text.txt", "rt")

print(f.read(5))
print(f.read(5))
print(f.read(4))
print(f.read())

f.close()
```

Файлы можно читать не только целиком или посимвольно, но и построчно. Для этого у объекта файла есть
метод `readlines`, который возвращает список из строк файла.

```python
f = open("text.txt", "rt")

print(f.readlines())

f.close()
```

Функция `readlines` может принимать аргумент - целое число. Будет считано переданное количество
символов плюс оставшиеся символы в строке, на которой оказался указатель.

```python
f = open("text.txt", "rt")

print(f.readlines(15))

f.close()
```

Обратите внимания, что каждая строка в списке имеет в конце символ `\n`.

Функция `readlines` загружает все строки целиком и хранит их в оперативной памяти, что может быть
очень накладно, если файл занимает много места на жёстком диске. Можно читать файл построчно с
помощью функции `readline`

```python
f = open("text.txt", "rt")

print(f.readline())
print(f.readline())

f.close()
```

Также обратите внимание, что возвращённые строки имеют в конце символ `\n`.

Функция `readline` также принимает аргумент - целое число. Это число обозначает, какое максимальное
количество символов будет считано из строки

```python
f = open("text.txt", "rt")

print(f.readline(5))
print(f.readline(8))

f.close()
```

Ещё один способ прочитать файл построчно - использовать файл как итератором. Такой вариант
считается самым оптимизированным

```python
f = open("text.txt")
for line in f:
    line
```

### Запись

Теперь рассмотрим запись в файл. Для того чтобы можно было записывать информацию в файл, нужно
открыть файл в режиме записи. Для записи в файл используется функция `write`. При открытии файла на
запись из него полностью удаляется предыдущая информация.

```python
f = open("text.txt", "wt")

f.write("New string")
f.write("Another string")

f.close()
```

Если вы откроете файл в текстовом редакторе, то увидите, что строки `New string` и `Another string`
склеились. Так произошло, потому что между ними нет перевода символа перевода строки.

Также в файлах, открытых на запись, есть метод `writelines`, который позволяет записать несколко
строк в файл

```python
f = open("text.txt", "wt")

lines = [
    "New string\n",
    "Another string\n",
]
f.writelines(lines)

f.close()
```

### Дозапись

Если нужно записать в конец файла какую-то информацию, то можно сделать это открыв файл в режиме
дозаписи. Все методы, доступные в режими записи также доступны в режиме дозаписи.

```python
f = open("text.txt", "at")

f.write("First string\n")
lines = [
    "Second string\n",
    "Third string\n",
]
f.writelines(lines)

f.close()
```

В PEP8 описано, что в конце файла с кодом всегда нужно оставлять пустую строку. Это правило кажется
надуманным, но сейчас мы знаем, что в любой файл, в котором последним символом стоит перевод строки
можер программно дозаписать любую строку и она не склеится с последней строкой в файле.

### Запись с возможностью чтения

Иногда нужно открыть файл с возможностью и записи, и чтения. В Python есть два режима:

* Запись с возможностью чтения (`w+`)
* Чтение с возможностью записи (`r+`)

На первый взгляд кажется, что они ничем не отличаются, но это не так.

При открытии файла на запись с возможностью чтения из файла полностью удаляется вся информация. Вы
можете записывать и читать из файла одновременно.

```python
f = open("text.txt", "w+t")

print(f.read())
f.write("Hello\n")
print(f.read())

f.close()
```

Как вы могли заметить, при чтении из файла никакой информации не выводится. Это поведение будет
объяснено чуть позже.

### Чтение с возможностью записи

При открытии файла на чтение с возможностью записи файл не перезаписывается.

```python
f = open("text.txt", "r+t")

print(f.read(1))
f.write("A")
f.read()

f.close()
```

Для того, чтобы понять каким образом произошло взаимодействие с файлом нужно посмотреть, какие
данные в нём хранятся теперь. Как вы могли заметить, символ `e` был заменён на `A` и это неспроста.
При записи символы в файле затирают символы, идущие следом, как если бы вы в текстовом редакторе
перевели указатель в середину текста, нажали insert и начали бы печатать.

### Двоичные файлы

Работа с двоичными файлами аналогична работе с текстовыми файлами, но есть небольшие различия. В
большинстве случаев вы не сможете открыть двоичный файл как текстовый, так как Python автоматически
производит декодирование байтов из файла в символы указанной кодировки и многие байты могут не
соответствовать ни одному символу из кодировки. И если текстовые файлы работают с данными типа
`str`, то бинарные файлы работают только со встроенными типами `bytes` и `bytearray`. Мы о них ещё
не говорили.

По сути, `bytes` и `bytearray` - это коллекции. По другому эти типы называют __байтовые строки__,
потому что они очень похожи на обычные строки, но при этом состоят не из символов, а из целых чисел
от 0 до 255, или байт. К ним применимы все методы, которые есть у обычных строк: find, replace,
split и т.д. Отличие между `bytes` и `bytearray` одно: `bytes` является неизменяемым типом данных, а
`bytearray` - изменяемым.

Для того чтобы создать объект типа `bytes` надо описать обычную строку и перед ней поставить символ
`b`:

```python
obj = b"Hello, world!"
```

В отличии от обычных строк, в `bytes` могут быть не только символы юникода, но и байты, которые
никак с юникодом не связаны

```python
obj = b"Hello\x0D\x0A\x41\x00"
print(obj)
```

Их можно указывать в шестнадцетеричном виде с помощью префикса `\x` и в восьмеричном с помощью
префикса `\`.

```python
f = open("data.dat", "wb")

f.writelines([b"A", b"\n"])
f.write(b"23")

f.close()
f = open("data.dat", "rb")

print(f.read())

f.close()
```

## 4. Указатель

Вы, наверное, заметили, что при чтении файла функция `read` читает символы друг за другом, если
вызвать её несколько раз с каким-либо аргументом, а при записи в файл все строки (строки байт)
записываются последовательно друг за другом. Это поведение объясняется тем, что python хранит
спецаильный указатель, позиция этого указателя говорит, с какого места читать из файла или писать в
файл.

Независимо от того в каком режиме открыт файл у каждого объекта файла есть методы `tell` и `seek`.
Метод `tell` возвращает целое число - позицию, где сейчас находится указатель. Метод `seek`
принимает целое число и переносит указатель в указанную позицию. Например, передвинуть указатель
на две позиции вперёд можно следующим образом

```python
# Пусть есть некий открытый файл f

position = f.tell()
f.seek(position + 2)
```

## 5. Оператор with

Конструкция `with ... as` используется для оборачивания выполнения блока инструкций менеджером
контекста. Иногда это более удобная конструкция, чем `try...except...finally`.

Синтаксис конструкции `with ... as`:

```python
with expression ["as" target] (, expression [as target])*:
    suite
```

Теперь по порядку о том, что происходит при выполнении данного блока:

1. Выполняется выражение в конструкции __with__ ... __as__.
2. Загружается специальный метод __\_\_exit\_\___ для дальнейшего использования.
3. Выполняется метод __\_\_enter\_\___. Если конструкция __with__ включает в себя слово __as__, то
возвращаемое методом __\_\_enter\_\___ значение записывается в переменную.
4. Выполняется suite.
5. Вызывается метод __\_\_exit\_\___, причём неважно, выполнилось ли suite или произошло исключение.
В этот метод передаются параметры исключения, если оно произошло, или во всех аргументах значение
None, если исключения не было.

Если в конструкции __with__ - __as__ было несколько выражений, то это эквивалентно нескольким
вложенным конструкциям:

```python
with A() as a, B() as b:
    suite
```

эквивалентно

```python
with A() as a:
    with B() as b:
        suite
```

Для чего применяется конструкция __with__ ... __as__? Для гарантии того, что критические функции
выполнятся в любом случае. Самый распространённый пример использования этой конструкции - открытие
файлов. Я уже рассказывал об открытии файлов с помощью функции open, однако конструкция
__with__ ... __as__, как правило, является более удобной и гарантирует закрытие файла в любом
случае. Например:

```python
with open("newfile.txt", "w", encoding="utf-8") as f:
    d = int(input())
    f.write("1 / {} = {}".format(d, 1 / d))
```

И вы можете быть уверены, что файл будет закрыт вне зависимости от того, что введёт пользователь.

## 6. Сериализация, десериализация

Сериализация (в программировании) (англ. serialization) — процесс перевода какой-либо структуры
данных в любой другой, более удобный для хранения формат. Обратной к операции сериализации является
операция десериализации (структуризации) (англ. deserialization) — восстановление начального
состояния структуры данных из битовой последовательности.
Сериал
Самой основной структурой данных в языке программирования Python является объект. Сериализация и
десериализация объектов используется в том случае, если нам надо передавать информацию между
запусками одной программы или между несколькими программами (продуктами и прочим). Есть множество
способов сохранить/восстановить объект.

## 7. Pickle

Модуль pickle реализует мощный алгоритм сериализации и десериализации объектов Python. "Pickling" -
процесс преобразования объекта Python в поток байтов, а "unpickling" - обратная операция, в
результате которой поток байтов преобразуется обратно в Python-объект. Так как поток байтов легко
можно записать в файл, модуль pickle широко применяется для сохранения и загрузки сложных объектов в
Python.

Модуль pickle предоставляет следующие функции для удобства сохранения/загрузки объектов:

* pickle.dump(obj, file, protocol=None, *, fix_imports=True)

Записывает сериализованный объект в файл. Дополнительный аргумент protocol указывает используемый
протокол. По умолчанию равен 3 и именно он рекомендован для использования в Python 3 (несмотря на
то, что в Python 3.4 добавили протокол версии 4 с некоторыми оптимизациями). В любом случае,
записывать и загружать надо с одним и тем же протоколом.

* pickle.dumps(obj, protocol=None, *, fix_imports=True) - возвращает сериализованный объект.
Впоследствии вы его можете использовать как угодно.
* pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict") - загружает объект из
файла.
* pickle.loads(bytes_object, *, fix_imports=True, encoding="ASCII", errors="strict") - загружает
объект из потока байт.

Модуль pickle также определяет несколько исключений:

* pickle.PickleError
* * pickle.PicklingError - случились проблемы с сериализацией объекта.
* * pickle.UnpicklingError - случились проблемы с десериализацией объекта.

```python
import pickle
```

Как использовать консервацию объектов? У вас есть два варианта: либо консервировать объект в строку
(которую можно передать через сокет, например) либо сразу в файл.

Есть три протокола консервации:

* Версия 0, стандартный ASCII протокол. Его следует использовать только для совместимости с ранними
версиями Питона.
* Версия 1 — примерно то же самое, используется для совместимости со старыми версиями Питона.
* Версия 2 впервые внедрена в версии 2.3, она лучше всего запаковывает объекты, написанные в
современном синтаксисе, я рекомендую использовать именно её.

Конвентирование объекта в строку и распакова обратно:

```python
import pickle

obj = {"one": 123, "two": [1, 2, 3]}
output = pickle.dumps(obj, 2)
new_obj = pickle.loads(output)
```

Протокол консервирования определяется автоматически.
Давайте попробуем запаковать объект в файл.

```python
import pickle

obj = {"one": 123, "two": [1, 2, 3]}
with open("data.pkl", "wb") as f:
    pickle.dump(obj, f, 2)
```

Обратите внимание, что режим записи в файл должен обязательно быть wb, то есть перезапись файла в
бинарном режиме. Для чтения режим должен быть rb:

```python
import pickle

with open("data.pkl", "rb") as f:
    obj = pickle.load(f)
```

## 8. JSON

JSON (англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript.
Как и многие другие текстовые форматы, JSON легко читается людьми. Формат JSON был разработан
Дугласом Крокфордом.
Для работы с форматом JSON в Python используется модуль json

```python
import json
```

* json.dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True,
cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) - сериализует obj как
форматированный JSON поток в fp.
Если skipkeys = True, то ключи словаря не базового типа (str, unicode, int, long, float, bool, None)
будут проигнорированы, вместо того, чтобы вызывать исключение TypeError.

Если ensure_ascii = True, все не-ASCII символы в выводе будут экранированы последовательностями
\uXXXX, и результатом будет строка, содержащая только ASCII символы. Если ensure_ascii = False,
строки запишутся как есть.

Если check_circular = False, то проверка циклических ссылок будет пропущена, а такие ссылки будут
вызывать OverflowError.

Если allow_nan = False, при попытке сериализовать значение с запятой, выходящее за допустимые
пределы, будет вызываться ValueError (nan, inf, -inf) в строгом соответствии со спецификацией JSON,
вместо того, чтобы использовать эквиваленты из JavaScript (NaN, Infinity, -Infinity).

Если indent является неотрицательным числом, то массивы и объекты в JSON будут выводиться с этим
уровнем отступа. Если уровень отступа 0, отрицательный или "", то вместо этого будут просто
использоваться новые строки. Значение по умолчанию None отражает наиболее компактное представление.
Если indent - строка, то она и будет использоваться в качестве отступа.

Если sort_keys = True, то ключи выводимого словаря будут отсортированы.

* json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None,
indent=None, separators=None, default=None, sort_keys=False, **kw) - сериализует obj в строку
JSON-формата.
* json.load(fp, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None,
object_pairs_hook=None, **kw) - десериализует JSON из fp.

object_hook - опциональная функция, которая применяется к результату декодирования объекта (dict).
Использоваться будет значение, возвращаемое этой функцией, а не полученный словарь.

object_pairs_hook - опциональная функция, которая применяется к результату декодирования объекта с
определённой последовательностью пар ключ/значение. Будет использован результат, возвращаемый
функцией, вместо исходного словаря. Если задан так же object_hook, то приоритет отдаётся
object_pairs_hook.

parse_float, если определён, будет вызван для каждого значения JSON с плавающей точкой.
По умолчанию, это эквивалентно float(num_str).

parse_int, если определён, будет вызван для строки JSON с числовым значением. По умолчанию
эквивалентно int(num_str).

parse_constant, если определён, будет вызван для следующих строк: "-Infinity", "Infinity", "NaN".
Может быть использовано для возбуждения исключений при обнаружении ошибочных чисел JSON.

Если не удастся десериализовать JSON, будет возбуждено исключение ValueError.

* json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None,
parse_constant=None, object_pairs_hook=None, **kw) - десериализует s (экземпляр str, содержащий
документ JSON) в объект Python.
Остальные аргументы аналогичны аргументам в load().

### Кодировщики и декодировщики

Класс json.JSONDecoder(object_hook=None, parse_float=None, parse_int=None, parse_constant=None,
strict=True, object_pairs_hook=None) - простой декодер JSON.

Выполняет следующие преобразования при декодировании:

|JSON         |Python|
|-------------|------|
|object       |dict  |
|array        |list  |
|string       |str   |
|number (int) |int   |
|number (real)|float |
|true         |True  |
|false        |False |
|null         |None  |
Он также понимает NaN, Infinity, и -Infinity как соответствующие значения float, которые находятся
за пределами спецификации JSON.

Класс json.JSONEncoder(skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True,
sort_keys=False, indent=None, separators=None, default=None)

Расширяемый кодировщик JSON для структур данных Python. Поддерживает следующие объекты и типы данных
по умолчанию:

|Python     |JSON  |
|-----------|------|
|dict       |object|
|list, tuple|array |
|str        |string|
|int, float |number|
|True       |true  |
|False      |false |
|None       |null  |

Сериализация и десериализация

```python
import json

obj = {"one": 123, "two": [1, 2, 3]}
output = json.dumps(obj)
new_obj = json.loads(output)
```

Сериализация в файл

```python
import json

obj = {"one": 123, "two": [1, 2, 3]}
with open("data.json", "wt") as f:
    json.dump(obj, f, indent=4)
```

Десериализация из файла

```python
import json

with open("data.json", "rt") as f:
    obj = json.load(f)
```

## 9. YAML

YAML (акроним англ.  «Yet Another Markup Language» — «Ещё один язык разметки», позже — рекурсивный
акроним англ. «YAML Ain't Markup Language» — «YAML — не язык разметки») — «дружественный» формат
сериализации данных, концептуально близкий к языкам разметки, но ориентированный на удобство
ввода-вывода типичных структур данных многих языков программирования.
Для работы с файлами yaml в Python используется модуль yaml.

Установка

```shell
pip install pyyaml
```

Как pickle и json - библиотека yaml тоже имеет подобный набор функций, но в отличии от pickle и json
в ней нет функций `dumps` и `loads`. Функции `dump` и `load` включают в себя все возможности - и
простую сериализацию/десериализацию, и сериализацию/десериализацию в файл.

Сериализация и десериализация

```python
import yaml

obj = {"one": 123, "two": [1, 2, 3]}
output = yaml.dump(obj)
new_obj = yaml.load(new_obj)
```

Сериализация в файл

```python
import yaml

obj = {"one": 123, "two": [1, 2, 3]}
with open("data.yml", "wt") as f:
    yaml.dump(obj, f)
```

Десериалиазация из файла

```python
import yaml

with open("data.yml", "wt") as f:
    obj = yaml.load(f)
```

## 10. Домашняя работа

Обязательно:

* №111327 (<https://informatics.msk.ru/mod/statements/view3.php?id=5763&chapterid=111327>)
* №111328 (<https://informatics.msk.ru/mod/statements/view3.php?id=5763&chapterid=111328>)
* №111329 (<https://informatics.msk.ru/mod/statements/view3.php?id=5763&chapterid=111329>)
* №111335 (<https://informatics.msk.ru/mod/statements/view3.php?id=5763&chapterid=111335>)

По желанию:

* Прочесть Марк Лутц - Главы 16-20
