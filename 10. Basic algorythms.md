# Основные алгоритмы

## 1. Понятие сложности алгоритма

Для выполнения любого алгоритма ЭВМ тратит определённое время и ресурсы. При оценке алгоритмов
ресурсами считается оперативная память, которую определённый алгоритм тратит на выполнение.

Очевидно, что один и тот же алгоритм на разных ЭВМ может тратить разное количество времени на
выполнение и даже разное количество оперативной памяти. Если алгоритм реализован на разных языках
программирования, то это также существенно влияет на его производительность, что делает невозможной
оценку алгоритма по данным показателям. Поэтому при оценке алгоритмов стараются абстрагироваться от
величин времени и опративной памяти и рассматривать алгоритм с чисто математической точки зрения.

Каждый алгоритм можно условно представить как функцию, в которую передаются какие-то абстрактные
данные и с которыми производиться какая-то работа. За количество этих данных принимается либо
какое-то число (если оно фиксировано), либо n (если данные - это одномерный массив),
либо n^2 (если данные - двумерный массив) и т.д. Если для работы алгоритма следует выделить
память, которая как либо зависит от количество данных (линейно, квадратично, логарифмически и т.д.),
то она и является требуемой памятью для выполнения алгоритма и записывается как O(n), где n -
требуемое количество памяти.

В алгоритме описана какая-то последовательность действий. Если некоторые действия в алгоритме
выполняются повторно и количество их выполнения зависит от количества переданных данных, то время
работы алгоритма также принимается за 1, n, n^2 и т.д. и также записывается как O(n), где n -
количество итераций. Проще всего оценить время можно по нахождению в алгоритме циклов и рекурсий.
Если есть один цикл, который выполняется n раз, то его сложность алгоритма по времени - O(n). Если
внутри этого цикла находится ещё один цикл, который выполняется n раз, то O(n^2) и т.д.

## 2. Алгоритмы поиска

### Линейный поиск

Линейный поиск - самый простой алгоритм поиска элемента в каком-то массиве данных.

Его сложность по времени:

* в лучшем случае: O(1)
* в среднем: O(n)
* в худшем: O(n)

Его сложность по памяти: O(n)

Реализация на Python

```python
lst = [1, 5, 7, 3, -2, 2, 4]
need = 2

for element in lst:
    if element == need:
        print("FOUND!")
        break
else:
    print("NOT FOUND!")
```

Такой поиск подходит к любому массиву данных. Но легко представить, сколько будет выполняться поиск,
если количество элементов в массиве возрастёт до сотен миллионов. В худшем случае нам нужно будет
выполнить сотни миллионов итераций. Поэтому иногда применяют более оптимизированные алгоритмы
поиска, предварительно отсортировав массив.

### Бинарный (двоичный) поиск

Бинарный поиск позволяет найти требуемый элемент в отсортированном массиве, не проходя его весь, а
выбирая определённый сектор, где этот элемент может находиться.

Его сложность по времени:

* в лучшем случае: O(1)
* в среднем: O(log2(n + 1))
* в худшем: O(log2(n + 1))

Его сложность по памяти: O(n)

Реализация на Python:

```python
lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
need = 8

left = 0
right = len(lst) - 1
while left <= right:
    med = (left + right) // 2
    if lst[med] > need:
        right = med - 1
    elif lst[med] < need:
        left = med + 1
    else:
        print("FOUND!")
        break
else:
    print("NOT FOUND!")
```

Также можно реализовать бинарный поиск используя отличительные возможности Python:

```python
lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
need = 8

lst_copy = lst.copy()
while lst_copy:
    med = lst_copy[len(lst_copy) // 2]
    if med > need:
        lst_copy = lst_copy[:len(lst_copy) // 2]
    elif med < need:
        lst_copy = lst_copy[len(lst_copy) // 2 + 1:]
    else:
        print("FOUND!")
        break
else:
    print("NOT FOUND!")
```

## 3. Самостоятельная работа

На <http://informatics.msk.ru>:

* № 223 (<https://informatics.msk.ru/mod/statements/view.php?id=270>)
* № 2 (<https://informatics.msk.ru/mod/statements/view3.php?id=192&chapterid=2>)

## 4. Алгоритмы сортировки

Довольно часто перед программистом встаёт задача отсортировать данные в определённом порядке. Для
решения данной задачи было придумано множество алгоритмов с разными показателями сложности.

### Сортировка пузырьком

Самая простая сортировка, которую используют - называется сортировка пузырьком

Его сложность по времени: O(n ** 2)

Его сложность по памяти: O(n)

Реализация на Python:

```python
a = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
n = len(lst)

for i in range(1, n):
    for j in range(0, n - i):
        if a[j] > a[j + 1]:
            a[j], a[j + 1] = a[j + 1], a[j]
```

### Сортировка вставками

Анимация, наглядно показывающая принцип сортировки вставками

<https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif>

Его сложность по времени:

* в лучшем случае:
* в среднем:
* в худшем:

### Быстрая сортировка

## 5. Самостоятельная работа

На <http://informatics.msk.ru>:

* № 1411 (<https://informatics.msk.ru/mod/statements/view3.php?id=271&chapterid=1411>)
* № 231 (<https://informatics.msk.ru/mod/statements/view3.php?id=271&chapterid=231>)

## 6. Домашнаяя работа

На informatics.msk.ru:

* № 1436 (<https://informatics.msk.ru/mod/statements/view3.php?id=271&chapterid=1436>)
* № 2 (<https://informatics.msk.ru/mod/statements/view3.php?id=192&chapterid=2>)
