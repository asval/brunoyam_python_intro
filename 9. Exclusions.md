# Исключения

## 1. Понятие исключения

Исключения (exceptions) - ещё один тип данных в python. Исключения необходимы для того, чтобы
сообщать программисту об ошибках.

## 2. Генерация исключения

Напишем код, который будет создавать исключительную ситуацию. К примеру, попробуем поделить число на
0:

```python
print(100 / 0)
```

В командной оболочке получим следующее:

```python
Traceback (most recent call last):
  File "", line 1, in
    print(100 / 0)
ZeroDivisionError: division by zero
```

Разберём это сообщение подробнее:

* Интерпретатор нам сообщает о том, что он поймал исключение и напечатал информацию:
`Traceback (most recent call last)`.
* Далее имя файла `File ""`. Имя пустое, потому что этот код был запущен в интерактивном
интерпретаторе, строка в файле `line 1`;
* Выражение, в котором произошла ошибка `print(100 / 0)`.
* Название исключения `ZeroDivisionError` и краткое описание исключения `division by zero`.

Разумеется, возможны и другие исключения:

```python
print(2 + '1')
```

Исключение:

```python
Traceback (most recent call last):
  File "", line 1, in
    print(2 + '1')
TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

```python
int('qwerty')
```

Исключение:

```python
Traceback (most recent call last):
  File "", line 1, in
    int('qwerty')
ValueError: invalid literal for int() with base 10: 'qwerty'
```

При выбросе исключения программа закрывается и не выполняет код, который следует за строкой, в
которой произошло исключение.

### Как работает выброс исключения

Для наглядного примера работы исключений создадим небольшой пакет из двух файлов: **main.py** и
**calc.py**.

```python
# main.py
from calc import div

result = div(100, 0)
print(result)
```

```python
# calc.py
def div(a, b):
    return a / b
```

При запуске файла **main.py** получим ошибку **ZeroDivisionError**. Сначала она появляется в третьей
строке файла **calc.py**, потом она поднимается по стеку вызова вверх и оказывается на 4 строке
файла **main.py**. Код на 5 и последующих строках в файле **main.py** уже не будет выполнен.

## 3. Перехват исключения

Не каждое исключение, которое вызывается в приложении, должно быть фатальным и приводить к закрытию
программы. Явным примером, когда этого не следует делать являются web-серверы. Представим, что у
одного пользователя произошла ошибка и web-сервер прекратил работу. Таким образом другие
пользователи тоже теряют доступ к web-серверу. Такое поведение было бы на руку злоумышленнику, чьей
целью была бы недоступность этого самого web-сервера.

Для того, чтобы предотвратить закрытие программы при генерации исключения, его можно перехватить с
помощью конструкции `try ... except ... [finally] ...`.

Попробуем перехватить исключение, которое генерируется в предыдущем примере. Попробуем перехватить
его на самом высоком уровне - в файле **main.py**.

```python
# main.py
from calc import div

try:
    result = div(100, 0)
    print("Расчёт проведён успешно")
except:
    print("Получилась ошибка какая-то")
print(result)
```

Если в блоке, который находится под **try** - происходит ошибка, то она перехватывается и
выполняется действие в блоке **except**. Отлов всех исключений считается плохой практикой, так как
мы можем не узнать об исключениях, которые могли произойти благодаря ошибками в коде или неожиданным
последствиям, которые мы не предусмотрели, поэтому всегда рекомендуется указывать класс исключения,
который мы собираемся отлавливать.

```python
# main.py
from calc import div

try:
    result = div(100, 0)
    print("Расчёт проведён успешно")
except ZeroDivisionError:
    print("Ошибка деления на ноль произошла")
print(result)
```

Если мы хотим не просто отловить ошибку, а получить и сам объект исключения, то его можно явно
указать в блоке except

```python
# main.py
from calc import div

try:
    result = div(100, 0)
    print("Расчёт проведён успешно")
except ZeroDivisionError as e:
    print("Вот такая ошибка деления произошла:", e)
print(result)
```

Иногда нам нужно перехватывать больше чем одно исключение и выполнять для них одинаковые действия

```python
# main.py
from calc import div

try:
    result = div(100, 0)
    print("Расчёт проведён успешно")
except (ZeroDivisionError, KeyError) as e:
    print("Ошибка деления или ошибка обращения по ключу. Вот она:", e)
print(result)
```

Если при перехвате разных ошибок нужно выполнять разные действия:

```python
# main.py
from calc import div

try:
    result = div(100, 0)
    print("Расчёт проведён успешно")
except ZeroDivisionError as e:
    print("Вот такая ошибка деления произошла", e)
except KeyError as e:
    print("Вот такая ошибка обращения по ключу произошла:", e)
print(result)
```

Также в конструкцию перехвата исключений можно добавить блок finally - он выполняется всегда, в
независимости от того, было ли поймано исключение или нет

```python
# main.py
from calc import div

try:
    result = div(100, 0)
    print("Расчёт проведён успешно")
except ZeroDivisionError as e:
    print("Вот такая ошибка деления произошла", e)
except KeyError as e:
    print("Вот такая ошибка обращения по ключу произошла:", e)
finally:
    print("Выполнение расчёта закончено")
print(result)
```

## 4. Стандартные исключения

* BaseException - базовое исключение, от которого берут начало все остальные.
* * SystemExit - исключение, порождаемое функцией sys.exit при выходе из программы.
* * KeyboardInterrupt - порождается при прерывании программы пользователем (обычно сочетанием клавиш
Ctrl+C).
* * GeneratorExit - порождается при вызове метода close объекта generator.
* * Exception - а вот тут уже заканчиваются полностью системные исключения (которые лучше не
трогать) и начинаются обыкновенные, с которыми можно работать.
* * * StopIteration - порождается встроенной функцией next, если в итераторе больше нет элементов.
* * * ArithmeticError - арифметическая ошибка.
* * * * FloatingPointError - порождается при неудачном выполнении операции с плавающей запятой. На
практике встречается нечасто.
* * * * OverflowError - возникает, когда результат арифметической операции слишком велик для
представления. Не появляется при обычной работе с целыми числами (так как python поддерживает
длинные числа), но может возникать в некоторых других случаях.
* * * * ZeroDivisionError - деление на ноль.
* * * AssertionError - выражение в функции assert ложно.
* * * AttributeError - объект не имеет данного атрибута (значения или метода).
* * * BufferError - операция, связанная с буфером, не может быть выполнена.
* * * EOFError - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
* * * ImportError - не удалось импортирование модуля или его атрибута.
* * * LookupError - некорректный индекс или ключ.
* * * * IndexError - индекс не входит в диапазон элементов.
* * * * KeyError - несуществующий ключ (в словаре, множестве или другом объекте).
* * * MemoryError - недостаточно памяти.
* * * NameError - не найдено переменной с таким именем.
* * * * UnboundLocalError - сделана ссылка на локальную переменную в функции, но переменная не
определена ранее.
* * * OSError - ошибка, связанная с системой.
* * * * BlockingIOError
* * * * ChildProcessError - неудача при операции с дочерним процессом.
* * * * ConnectionError - базовый класс для исключений, связанных с подключениями.
* * * * * BrokenPipeError
* * * * * ConnectionAbortedError
* * * * * ConnectionRefusedError
* * * * * ConnectionResetError
* * * * FileExistsError - попытка создания файла или директории, которая уже существует.
* * * * FileNotFoundError - файл или директория не существует.
* * * * InterruptedError - системный вызов прерван входящим сигналом.
* * * * IsADirectoryError - ожидался файл, но это директория.
* * * * NotADirectoryError - ожидалась директория, но это файл.
* * * * PermissionError - не хватает прав доступа.
* * * * ProcessLookupError - указанного процесса не существует.
* * * * TimeoutError - закончилось время ожидания.
* * * ReferenceError - попытка доступа к атрибуту со слабой ссылкой.
* * * RuntimeError - возникает, когда исключение не попадает ни под одну из других категорий.
* * * NotImplementedError - возникает, когда абстрактные методы класса требуют переопределения в
дочерних классах.
* * * SyntaxError - синтаксическая ошибка.
* * * * IndentationError - неправильные отступы.
* * * * * TabError - смешивание в отступах табуляции и пробелов.
* * * SystemError - внутренняя ошибка.
* * * TypeError - операция применена к объекту несоответствующего типа.
* * * ValueError - функция получает аргумент правильного типа, но некорректного значения.
* * * UnicodeError - ошибка, связанная с кодированием / раскодированием unicode в строках.
* * * * UnicodeEncodeError - исключение, связанное с кодированием unicode.
* * * * UnicodeDecodeError - исключение, связанное с декодированием unicode.
* * * * UnicodeTranslateError - исключение, связанное с переводом unicode.
* * * Warning - предупреждение.

Все встроенные классы исключения унаследованы от класса `BaseException`, от него унаследуются такие
стандартные классы, как `SystemExit` - который отвечает за закрытие программы посредством функции
`exit` и `KeyboardInterrupt` - который отвечает за закрытие программы с помощью нажатия
`<Ctrl>+<Break>`. Также есть класс `Exception`, от которого унаследуются все остальные классы.

Если требуется перехватить все исключения, то нужно делать это либо:

```python
try:
    ...
except:
    ...
```

либо:

```python
try:
    ...
except Exception:
    ...
```

Перехватывать исключения, дочерние для `BaseException` не рекомендуется, так как вы заблокируете
системные `SystemExit` и `KeyboardInterrupt`.

## 5. Создание класса исключения

Так как исключения представлены как классы, то мы также можем создавать и собственные исключения. В
предыдущем примере мы перехватывали исключение `ZeroDivisionError`, но это исключение не несло в
себе никакой полезной информации. Всё, что мы знали, это то, что произошло деление на 0. Давайте
создадим собственный класс `MyZeroDivisionError`, который также будет хранить внутри себя информацию
о том, какое число было поделено на 0. Пусть класс исключения будет хранится в модуле
`exceptions.py`.

```python
# exceptions.py
class MyZeroDivisionError(ZeroDivisionError):
    def __init__(self, number):
        super().__init__(f"{number} was division by zero")
        self.number = number
```

Так как класс является наследником `ZeroDivisionError`, то при перехвате исключения класса
`ZeroDivisionError` также будет перехватываться исключение класса `MyZeroDivisionError`.

## 6. Выброс исключения

Мы создали класс, но нам теперь нужно сделать так, чтобы в момент когда происходит деление на 0
выбрасывалось не `ZeroDivisionError`, а `MyZeroDivisionError`. Мы можем перехватить
`ZeroDivisionError` в момент, когда оно выбрасывается на самом низком уровне и вместо него выбросить
исключение `MyZeroDivisionError`. Для выброса исключения используется оператор `raise`:

```python
# calc.py
from exceptions import MyZeroDivisionError

def div(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        raise MyZeroDivisionError(a)
```

## 7. Домашнее задание

Обязательно:

* №3460 (<https://informatics.msk.ru/mod/statements/view3.php?id=3309&chapterid=3460>)
* №3612 (<https://informatics.msk.ru/mod/statements/view3.php?id=3716&chapterid=3612>)
* №3745 (<https://informatics.msk.ru/mod/statements/view3.php?id=3863&chapterid=3745>)
* №3828 (<https://informatics.msk.ru/mod/statements/view.php?id=4163>)
